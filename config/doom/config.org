#+TITLE: My configuration
#+date: 2021-7-19
#+STARTUP: content
* Introduction
This is my literate configuration for doom emacs. I barley know [[https://learnxinyminutes.com/docs/elisp/][elisp]]  and I have
mostly stolen snippets from others. This config is [[elisp:(count-words (point-min) (point-max))][this many]] words, lines and
characters long. Its a lot of blood sweat and tears so I hope you like it as much
as I tolerate it!

#+begin_quote
Do note I don't try to explain how things work but I do try to explain my
motivation behind my config. I was told this is not the norm but this is my
config and =C-h f= exists so you can go have a look
#+end_quote

Lets get this config started!
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
;; Don't edit this file directly unless you like your changes being wiped
#+END_SRC

** Table of Contents :TOC_3:
- [[#introduction][Introduction]]
- [[#rudimentary-configuration][Rudimentary configuration]]
  - [[#keybinds][Keybinds]]
  - [[#hooky-hooks][Hooky hooks]]
  - [[#cli-commands][cli commands]]
  - [[#funky-functions][funky functions]]
  - [[#macros][macros]]
  - [[#random-modes][Random modes]]
    - [[#display-time-mode][display time mode]]
    - [[#globalsubword-mode][GlobalSubWord Mode]]
    - [[#type-break-mode][Type break mode]]
    - [[#battery-mode][Battery mode]]
    - [[#whitespace-mode][whitespace mode]]
  - [[#popup-rules][popup rules]]
- [[#packages][Packages]]
  - [[#ui][ui]]
    - [[#modeline-fun][modeline fun]]
    - [[#sidebars][sidebars]]
    - [[#themes][themes]]
  - [[#checkers][checkers]]
    - [[#flymake-vale][Flymake Vale]]
  - [[#emacs][emacs]]
    - [[#dired][dired]]
  - [[#tools][tools]]
    - [[#pretty-code-shots][pretty code shots]]
    - [[#snippets][snippets]]
    - [[#dictionary][dictionary]]
    - [[#info][info]]
  - [[#lang][lang]]
    - [[#org-mode][org mode]]
    - [[#emacs-lisp][emacs lisp]]
    - [[#sql][SQL]]
    - [[#caddy][Caddy]]
    - [[#vim][vim]]
    - [[#unit-tests][unit tests]]
    - [[#janet][janet]]
    - [[#shell][shell]]
  - [[#app][app]]
    - [[#books][books]]
    - [[#tldr-integration][tldr integration]]
    - [[#rss][rss]]
  - [[#other][other]]
    - [[#tetris][tetris]]
    - [[#fixes][fixes]]
    - [[#discord-rich-presence][discord rich presence]]
    - [[#arrows][arrows]]
- [[#modules][Modules]]
  - [[#completion][completion]]
    - [[#company][company]]
    - [[#deprecated-ivy][DEPRECATED ivy]]
    - [[#vertico][vertico]]
  - [[#editor][editor]]
    - [[#evil][evil]]
  - [[#ui-1][ui]]
    - [[#doom][Doom]]
    - [[#doom-dashboard][Doom Dashboard]]
    - [[#hl-todo][Hl TODO]]
    - [[#popup][Popup]]
    - [[#modeline][Modeline]]
    - [[#treemacs][Treemacs]]
    - [[#workspaces][Workspaces]]
  - [[#tools-1][tools]]
    - [[#eval][eval]]
    - [[#magit][magit]]
    - [[#lsp][lsp]]
    - [[#pdf][pdf]]
    - [[#tmux][tmux]]
    - [[#tree-sitter][tree-sitter]]
  - [[#emacs-1][emacs]]
    - [[#dired-1][dired]]
  - [[#term][term]]
    - [[#eshell][eshell]]
  - [[#checkers-1][checkers]]
    - [[#spell][spell]]
  - [[#lang-1][lang]]
    - [[#emacs-lisp-1][emacs-lisp]]
    - [[#org][org]]
    - [[#haskell][haskell]]
    - [[#python][python]]
    - [[#racket][racket]]
    - [[#latex][LaTeX]]
    - [[#web][Web]]
  - [[#app-1][app]]
    - [[#irc][irc]]
    - [[#rss-1][rss]]
    - [[#mu4e][mu4e]]
    - [[#everywhere][everywhere]]
- [[#epilogue][Epilogue]]

* Rudimentary configuration
This is the stuff that does not really belong in any module but is useful
#+BEGIN_SRC emacs-lisp
(message "in config")
(load! "+private.el") ;; Stuff I don't want on the web (emails and other boring things)
(setq user-full-name "Jeetaditya Chatterjee"
      user-mail-address "jeetelongname@gmail.com" ;; god I can't wait to get away from gmail
      doom-scratch-initial-major-mode 'lisp-interaction-mode
      auth-sources '("~/.authinfo.gpg")
      ispell-dictionary "en"
      display-line-numbers-type 'relative ;; this is a reminder that I should try and use relative actions more
      browse-url-browser-function 'browse-url-firefox)

(when (boundp 'native-comp-async-jobs-number)
  (setq native-comp-async-jobs-number 9))

(when (boundp 'pgtk-wait-for-event-timeout)
  (setq pgtk-wait-for-event-timeout 0.001))

(setq doom-leader-alt-key "M-SPC")
#+END_SRC


+I like a little separation so I put an empty line at the top of my emacs+
+instance (I may put something in it later)+

I never did as i moved to multi monitors
#+BEGIN_SRC emacs-lisp
;; (setq-default header-line-format (concat (propertize battery-mode-line-format 'display '((space :align-to 0))) " ")))
#+END_SRC

for those random scripts I find
#+begin_src emacs-lisp
(add-load-path! "lisp")
#+end_src
** Keybinds
These are my global keybinds they should not belong to any module. thus they
get stuck here
#+BEGIN_SRC emacs-lisp
(map!
 :n "z C-w" 'save-buffer ; I can use this onehanded which is nice when I need to leave or eat or something
 :g "C-`" #'+workspace/other ; faster than SPC w `
 :leader
 :desc "Enable Coloured Values" "t c" #'rainbow-mode
 :desc "Toggle Tabs" "t B" #'centaur-tabs-local-mode
 :desc "Open Elfeed" "o l" #'=rss
 :desc "Open Irc" "o c" #'=irc
 ;; I recompile more than I compile
 "cc" #'recompile
 "cC" #'compile)

(map! :map minibuffer-local-map doom-leader-alt-key #'doom/leader)
#+end_src
** Hooky hooks
hl-line and rainbow mode don't play all too well so if one is on the other
should be off
#+begin_src emacs-lisp
(add-hook! 'rainbow-mode-hook
  (hl-line-mode (if rainbow-mode -1 +1)))
#+end_src

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC
** cli commands
this adds a repl command so that I can run emacs lisp in a terminal repl. is it
useful? no is it cool? yes. is it mine? no thanks @tecosaur!

#+begin_src emacs-lisp :tangle packages.el
(package! engrave-faces
  :recipe (:host github :repo "tecosaur/engrave-faces"))
#+end_src

#+begin_src emacs-lisp :tangle cli.el
(defcli! repl ((in-rlwrap-p ["--rl"] "For internal use only."))
  "Start an elisp REPL."
  (when (and (executable-find "rlwrap") (not in-rlwrap-p))
    ;; For autocomplete
    (setq autocomplete-file "/tmp/doom_elisp_repl_symbols")
    (unless (file-exists-p autocomplete-file)
      (princ "\e[0;33mInitialising autocomplete list...\e[0m\n")
      (with-temp-buffer
        (cl-do-all-symbols (s)
          (let ((sym (symbol-name s)))
            (when (string-match-p "\\`[[:ascii:]][[:ascii:]]+\\'" sym)
              (insert sym "\n"))))
        (write-region nil nil autocomplete-file)))
    (princ "\e[F")
    (throw 'exit (list "rlwrap" "-f" autocomplete-file
                       (concat doom-emacs-dir "bin/doom") "repl" "--rl")))

  (doom-initialize-packages)
  (require 'engrave-faces-ansi)
  (setq engrave-faces-ansi-color-mode '3-bit)

  ;; For some reason (require 'parent-mode) doesn't work :(
  (defun parent-mode-list (mode)
    "Return a list of MODE and all its parent modes.

The returned list starts with the parent-most mode and ends with MODE."
    (let ((result ()))
      (parent-mode--worker mode (lambda (mode)
                                  (push mode result)))
      result))
  (defun parent-mode--worker (mode func)
    "For MODE and all its parent modes, call FUNC.

FUNC is first called for MODE, then for its parent, then for the parent's
parent, and so on.

MODE shall be a symbol referring to a function.
FUNC shall be a function taking one argument."
    (funcall func mode)
    (when (not (fboundp mode))
      (signal 'void-function (list mode)))
    (let ((modefunc (symbol-function mode)))
      (if (symbolp modefunc)
          ;; Hande all the modes that use (defalias 'foo-parent-mode (stuff)) as
          ;; their parent
          (parent-mode--worker modefunc func)
        (let ((parentmode (get mode 'derived-mode-parent)))
          (when parentmode
            (parent-mode--worker parentmode func))))))
  (provide 'parent-mode)
  ;; Some extra highlighting (needs parent-mode)
  (require 'rainbow-delimiters)
  (require 'highlight-quoted)
  (require 'highlight-numbers)
  (setq emacs-lisp-mode-hook '(rainbow-delimiters-mode
                               highlight-quoted-mode
                               highlight-numbers-mode))
  ;; Pretty print
  (defun pp-sexp (sexp)
    (with-temp-buffer
      (cl-prettyprint sexp)
      (emacs-lisp-mode)
      (font-lock-ensure)
      (with-current-buffer (engrave-faces-ansi-buffer)
        (princ (string-trim (buffer-string)))
        (kill-buffer (current-buffer)))))
  ;; Now do the REPL
  (defvar accumulated-input nil)
  (while t
    (condition-case nil
        (let ((input (if accumulated-input
                         (read-string "\e[31m .\e[0m  ")
                       (read-string "\e[31mλ:\e[0m "))))
          (setq input (concat accumulated-input
                              (when accumulated-input "\n")
                              input))
          (cond
           ((string-match-p "\\`[[:space:]]*\\'" input)
            nil)
           ((string= input "exit")
            (princ "\n") (kill-emacs 0))
           (t
            (condition-case err
                (let ((input-sexp (car (read-from-string input))))
                  (setq accumulated-input nil)
                  (pp-sexp (eval input-sexp))
                  (princ "\n"))
              ;; Caused when sexp in unbalanced
              (end-of-file (setq accumulated-input input))
              (error
               (cl-destructuring-bind (backtrace &optional type data . _)
                   (cons (doom-cli--backtrace) err)
                 (princ (concat "\e[1;31mERROR:\e[0m " (get type 'error-message)))
                 (princ "\n       ")
                 (pp-sexp (cons type data))
                 (when backtrace
                   (print! (bold "Backtrace:"))
                   (print-group!
                    (dolist (frame (seq-take backtrace 10))
                      (print!
                       "%0.74s" (replace-regexp-in-string
                                 "[\n\r]" "\\\\n"
                                 (format "%S" frame))))))
                 (princ "\n")))))))
      ;; C-d causes an end-of-file error
      (end-of-file (princ "exit\n") (kill-emacs 0)))
    (unless accumulated-input (princ "\n"))))
#+end_src
** funky functions
Because this is a literate config I can't re evaluate the buffer using
~eval-buffer~ (bound to =SPC m e b=) so I reload the file after its tangled (usually
on save)
(=m e b= becomes =h r c=)
#+BEGIN_SRC emacs-lisp :tangle autoload.el
;;;###autoload
(defun yeet/reload ()
  "A simple cmd to make reloading my config easier"
  (interactive)
  (load! "config" doom-private-dir)
  (message "Reloaded!"))
#+END_SRC

#+begin_src emacs-lisp
(map! :leader
      "h r c" #'yeet/reload)
#+end_src
some how this function is run on startup? not that I am complaining
#+BEGIN_SRC emacs-lisp :tangle autoload.el
;;;###autoload
(defun henlo ()
  "henlo."
  (interactive)
  (message "henlo"))

(henlo) ;; oh wait thats how

#+END_SRC

I don't have a problem ok I can =M-x stop= at any time
#+begin_src emacs-lisp :tangle autoload.el
;;;###autoload
(defun stop ()
  (interactive)
  (let ((name "*I can quit at any time*"))
    (switch-to-buffer (get-buffer-create name))
    (insert "I can stop at any time\nI am in control")))
#+end_src

thewe awe days whewe i nyeed to quickwy u-uwu a wawge a-amount of text w-wight in emacs
o-onwy wowks on an e-expwicit sewection a-at the moment [[https://github.com/Daniel-Liu-c0deb0t/uwu][this is the pwogwam i
use]] tho it couwd wowk with any uwu pwogwam t-that accepts s-stdin

#+begin_src emacs-lisp :tangle autoload.el
;;;###autoload
(defun uwu (start end)
  "Uwu the text between START and END."
  (interactive "r")
  (let ((str (buffer-substring-no-properties start end)))
    (goto-char start)
    (delete-region start end)
    (insert (format "%s" (shell-command-to-string ;; I have to pipe the text into uwuify unless making a temp-file is more your style
                          (concat "echo "
                                  "'" str "'"
                                  " | " (executable-find "uwuify")))))))
#+end_src

This snippet toggles between a vertical and horizontal window. Like most things
I did not write this I took it from [[https://www.emacswiki.org/emacs/ToggleWindowSplit][here]]
#+begin_src emacs-lisp :tangle autoload.el
;;;###autoload
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src

#+begin_src emacs-lisp
(defun ar/consult-apple-search ()
  "Ivy interface for dynamically querying apple.com docs."
  (interactive)
  (require 'request)
  (require 'json)
  (require 'url-http)
  (consult--read "apple docs: "
            (lambda (input)
              (let* ((url (url-encode-url (format "https://developer.apple.com/search/search_data.php?q=%s" input)))
                     (c1-width (round (* (- (window-width) 9) 0.3)))
                     (c2-width (round (* (- (window-width) 9) 0.5)))
                     (c3-width (- (window-width) 9 c1-width c2-width)))
                (let ((request-curl-options (list "-H" (string-trim (url-http-user-agent-string)))))
                   (request url
                     :type "GET"
                     :parser 'json-read
                     :success (cl-function
                               (lambda (&key data &allow-other-keys)
                                 (ivy-update-candidates
                                  (mapcar (lambda (item)
                                            (let-alist item
                                              (propertize
                                               (format "%s   %s   %s"
                                                       (truncate-string-to-width (propertize (or .title "")
                                                                                             'face '(:foreground "yellow")) c1-width nil ?\s "…")
                                                       (truncate-string-to-width (or .description "") c2-width nil ?\s "…")
                                                       (truncate-string-to-width (propertize (string-join (or .api_ref_data.languages "") "/")
                                                                                             'face '(:foreground "cyan1")) c3-width nil ?\s "…"))
                                               'url .url)))
                                          (cdr (car data)))))))
                   0)))
            ;; :action (lambda (selection)
            ;;           (browse-url (concat "https://developer.apple.com"
            ;;                               (get-text-property 0 'url selection))))
            ;; :dynamic-collection t
            ;; :caller 'ar/counsel-apple-search)
  ))

#+end_src

#+begin_src emacs-lisp
(map! :leader
      "w C-t" nil
      "w C-t" #'toggle-window-split)
#+end_src

I need more cats in my life
#+begin_src emacs-lisp
(defvar yeet/insert-cat-width nil
  "the width of the cats")

(defun yeet/insert-cat ()
  (interactive)
  (insert-before-markers
   (shell-command-to-string
    (format "jp2a --width= %s https://cataas.com/cat" (if yeet/insert-cat-width
                                                          yeet/insert-cat-width
                                                        60)))))
#+end_src
** macros
this is a small helper macro that wraps ~with-temp-buffer~ with an implicit call
to ~buffer-string~ I did this as I see this patter all over the place and
#+begin_src emacs-lisp
(defmacro with-temp-buffer! (&rest BODY)
  "A wrapper around `with-temp-buffer' that implicitly calls `buffer-string'
This is in an effort to streamline a very common usecase"
  (declare (indent 0) (debug t))
  `(with-temp-buffer
     (progn ,@BODY)
     (buffer-string)))
#+end_src

#+begin_src emacs-lisp :tangle no
(message "%s" (with-temp-buffer!
                (insert "hello\n")
                (insert "world!")))
#+end_src

#+RESULTS:
: hello
: world!

#+begin_src emacs-lisp
;; I plan on upstreamin this.
(defmacro thread-as (initial-form var &rest forms)
  "Thread INITIAL-FORM through FORMS as VAR to there successor.
Example:
     (thread-as
       5
       my-var
       (+ my-var 20)
       (/ 25 my-var)
       (+ my-var 40))
Is equivalent to:
     (+ (/ 25 (+ 5 20)) 40 )
Note that unlike the other threading macro's that every call needs to
explicitly use the variable."
  `(let* ,(mapcar (lambda (form)
                    (list var form))
                  (cons initial-form forms))
     ,var))

(thread-as 3 my-var (+ 2 my-var) (+ 4 my-var))
#+end_src

** Random modes
*** display time mode
#+begin_src emacs-lisp
(display-time-mode +1)
#+end_src
*** GlobalSubWord Mode
#+begin_src emacs-lisp
(global-subword-mode +1)
#+end_src
*** TODO Type break mode
Type break reminds you too take a break once a certain threshold of keys has
been met. Its nice if its not too frequent
#+begin_src emacs-lisp
(use-package! type-break
  :defer
  :config
  (setq type-break-interval 1800 ;; half an hour between type breaks
        type-break-keystroke-threshold (cons 2000  14000))
  (type-break-mode 1))
#+end_src
*** Battery mode
I like my modeline busy
#+begin_src emacs-lisp
(display-battery-mode 1)
#+end_src
*** whitespace mode
#+begin_src emacs-lisp
(setq whitespace-style '(space-mark))
(setq whitespace-display-mappings '((space-mark 32 [183] [46])))
(global-whitespace-mode)
#+end_src
** popup rules
#+begin_src emacs-lisp
(set-popup-rules!
  '(("^\\*info\\*"
     :slot 1 :vslot 1 :side right :width 0.45 :quit nil)))
#+end_src
* Packages
I have quite a few packages that I use. These are the packages and there
subsequent configurations.
Here they are organised into the catagories and modules they would be if they
were doom modules
#+BEGIN_SRC emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+END_SRC
** ui
*** modeline fun :modeline:
/whats life without a little colour?/
#+begin_src emacs-lisp :tangle packages.el
(package! nyan-mode)
(package! parrot)
#+end_src

#+begin_src emacs-lisp
(defvar yeet/birds '(default confused emacs nyan rotating science thumbsup))

(use-package! nyan-mode
  :after doom-modeline
  :config
  (setq nyan-bar-length 15
        nyan-wavy-trail t)
  (nyan-mode +1)
  (nyan-start-animation))

(use-package! parrot
  :defer t
  :config
  (parrot-set-parrot-type (nth (random (length yeet/birds)) yeet/birds)) ;; this chooses a random bird on startup
  (parrot-mode +1)
  (parrot-start-animation))

;; (add-to-list 'marginalia-prompt-categories '("bird" . bird))

(defun bird-annotations (cand)
  "Takes a CANDidate (which is a bird) and returns a description of said bird"
  (let ((yeet/birds+annotations (-zip-pairs yeet/birds '("default bird is best bird"
                                                         "they have got the spirit"
                                                         "EMACS BIRD EMACS BIRD"
                                                         "nananananan"
                                                         "you spin me right round right round like a record baby"
                                                         "science bitch!"
                                                         "He is just happy to be here"))))
    (cdr (assoc cand yeet/birds+annotations))))

;; (add-to-list 'marginalia-annotator-registry '(bird bird-annotations))
#+end_src

#+begin_src emacs-lisp :tangle autoload.el
;;;###autoload
(defun yeet/select-bird (bird)
  "Select BIRD from birds"
  (interactive (list (completing-read "Select bird: " birds)))
  (parrot-set-parrot-type bird))
#+end_src
*** sidebars :sidebars:
By virtue of these things I seem to have 3 different sidebars (4 if you include
treemacs) that I have taken a liking to so they get there own sub genre

#+begin_src emacs-lisp
(defun yeet/sidebar-toggle ()
  "toggle both ibuffer and dired sidebars"
  (interactive)
  (ibuffer-sidebar-toggle-sidebar)
  (dired-sidebar-toggle-sidebar))

(map! :leader "o p" nil
      :leader "o p" #'dired-sidebar-toggle-sidebar ;; this is more useful most of the time
      :leader "o P" #'yeet/sidebar-toggle) ;; this is when I need too do some buffer management
#+end_src

**** Dired sidebar
this is a replacement for treemacs. Now don't get me wrong. I like treemacs. Its
great but its /not dired/. This preserves a lot of the dired configuration I could
do and more importantly preserves keys which is nice
#+begin_src emacs-lisp :tangle packages.el
(package! dired-sidebar)
#+end_src

#+begin_src emacs-lisp
;; (after! dired-sidebar (add-hook! 'dired-sidebar-mode-hook (doom-modeline-mode -1)))

(use-package! dired-sidebar
  :defer t
  :commands dired-sidebar-toggle-sidebar
  :config
  (setq dired-sidebar-use-custom-modeline t
        dired-sidebar-should-follow-file t))
#+end_src

**** Ibuffer sidebar
this is the same thing as above made by the same [[https://github.com/jojojames][author]] and it works just like
dired sidebar.. for Ibuffer
#+begin_src emacs-lisp :tangle packages.el
(package! ibuffer-sidebar)
#+end_src

#+begin_src emacs-lisp
(use-package! ibuffer-sidebar
  :commands ibuffer-sidebar-toggle-sidebar
  :defer t)
#+end_src
**** TODO Org Sidebar
this does a bunch of org stuff like break stuff down into headings. there is a
bit of work to be done
#+begin_src emacs-lisp :tangle packages.el
(package! org-sidebar)
#+end_src


#+begin_src emacs-lisp
(use-package! org-sidebar
  :after org)
#+end_src
*** themes
I set my themes in my  [[#doom][Doom config]]
#+begin_src emacs-lisp :tangle packages.el
(package! ef-themes :recipe (:host nil :repo "https://git.sr.ht/~protesilaos/ef-themes"))
(package! tao-theme)
#+end_src

#+begin_src emacs-lisp
(use-package ef-themes :defer t)

(use-package! tao-theme ; messing around with tao
  :defer
  :config
  (setq tao-theme-use-sepia t
        tao-theme-sepia-depth 50))
#+end_src
** checkers
*** COMMENT syntax
this is now a module doomemacs/doomemacs#6660
I have swapped out flycheck for flymake for a couple of reasons
- its built in
- its an easy switch
- its probably what doom is going to switch to
- 4th reason
#+begin_src emacs-lisp
(add-hook! (prog-mode text-mode) #'flymake-mode)

(after! lsp-mode
  (setq lsp-diagnostics-provider :flymake))

(after! flymake
  (setq flymake-fringe-indicator-position 'right-fringe))
#+end_src
**** popon hover
#+begin_src emacs-lisp :tangle packages.el
(package! popon :recipe (:repo "https://codeberg.org/akib/emacs-popon"))
(package! flymake-popon :recipe (:repo "https://codeberg.org/akib/emacs-flymake-popon"))
#+end_src

#+begin_src emacs-lisp
(use-package! flymake-popon
  :hook (flymake-mode . flymake-popon-mode))
#+end_src
**** remove checkdoc in certain buffers
#+begin_src emacs-lisp
(add-hook! 'flymake-mode-hook
  (defun +emacs-lisp-reduce-flymake-errors-in-emacs-config-h ()
    (when (and (bound-and-true-p flymake-mode)
               (eq major-mode 'emacs-lisp-mode)
               (cl-find-if (doom-partial #'file-in-directory-p default-directory)
                           +emacs-lisp-disable-flycheck-in-dirs))
      (remove-hook 'flymake-diagnostic-functions #'elisp-flymake-checkdoc))))
#+end_src

*** Flymake Vale
this replaces =:checkers grammer= and parts of =:checkers spell=
#+begin_src emacs-lisp :tangle packages.el
(package! flymake-vale :recipe (:host github :repo "tpeacock19/flymake-vale"))
#+end_src

#+begin_src emacs-lisp
(use-package! flymake-vale
  :hook ((text-mode       . flymake-vale-load)
         (latex-mode      . flymake-vale-load)
         (org-mode        . flymake-vale-load)
         (markdown-mode   . flymake-vale-load)
         (message-mode    . flymake-vale-load)))

(add-hook! 'org-msg-mode-hook
  (setq flymake-vale-file-ext ".org")
  (flymake-vale-load))
#+end_src

** emacs
*** dired :dired:
I want drag and drop so I just wrapped dragon in elisp the drag commands work
wellish
#+begin_src emacs-lisp :tangle packages.el
;; (package! dired-dragon :recipe (:local-repo "~/code/emacs/dired-dragon"
;;                                 :build (:not compile)))
(package! dired-dragon :recipe (:host github :repo "jeetelongname/dired-dragon"
                                :build (:not compile)))
#+end_src

#+begin_src emacs-lisp
(use-package! dired-dragon
  :after dired
  :config
  (map! :map dired-mode-map
        (:prefix "C-s"
         :n "d" #'dired-dragon
         :n "s" #'dired-dragon-stay
         :n "i" #'dired-dragon-individual)))
#+end_src

** tools
*** pretty code shots
i missed the ability to make pretty code shots inside vscode now its come back to
me through this package. its pretty cool and works well (it only does one thing)
#+begin_src emacs-lisp :tangle packages.el
(package! carbon-now-sh)
#+end_src

+i wanted to work with these code images directly in emacs so i brought in eaf to+
+help. do note that there is a bug in the pypi version of the qtwebengine that+
+basically segfaults if you open carbon (and probably other sites) if you install
from the repos tho this problem goes away+

I just went back to firefox since eaf is deprecated in my config
#+begin_src emacs-lisp
(use-package! carbon-now-sh
  :config
  (defun yeet/carbon-use-eaf ()
    (interactive)
    (split-window-right)
    (let ((browse-url-browser-function 'browse-url-firefox))
      (browse-url (concat carbon-now-sh-baseurl "?code="
                          (url-hexify-string (carbon-now-sh--region))))))
  (map! :n "g C-c" #'yeet/carbon-use-eaf))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
;; (package! screenshot. :recipe
;;   (:host github :repo "tecosaur/screenshot"))
#+end_src

#+begin_src emacs-lisp
;; (use-package! screenshot :defer)
#+end_src
*** snippets
I really need to play with snippets more
I need more gremlins
#+begin_src emacs-lisp :tangle packages.el
(package! aas)
(package! tempel)
#+end_src

#+begin_src emacs-lisp
(use-package! aas)
#+end_src
*** dictionary
tecosaurs [[https://github.com/tecosaur/lexic][lexic]] package is now powering my dictionary usage, This configuration
is basically stolen from [[https://tecosaur.github.io/emacs-config/config.html#dictionary][his config]] (like most things)

#+begin_src emacs-lisp :tangle packages.el
(package! lexic)
#+end_src

#+begin_src emacs-lisp
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

#+begin_src emacs-lisp
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
  #+end_src
*** info
#+begin_src emacs-lisp :tangle packages.el
(package! info-colors)
(package! info-buffer)
#+end_src

#+begin_src emacs-lisp
(use-package info-colors
  :hook (Info-selection-hook . info-colors-fontify-node))

;; (map! "C-h i" #'info-buffer)
#+end_src
** lang
*** org mode
**** TODO Company org block
#+begin_src emacs-lisp :tangle packages.el
(package! company-org-block)
#+end_src

#+begin_src emacs-lisp
(use-package! company-org-block
  :after org
  :config
  (setq company-org-block-edit-style 'auto))

(after! org
  (set-company-backend! 'org-mode-hook '(company-org-block company-capf))

  ;; (setq org-babel-load-languages
  ;;       '((elisp   . t)
  ;;         (python  . t)
  ;;         (ruby    . t)
  ;;         (haskell . t)
  ;;         (scheme  . t)
  ;;         (latex   . t)))
  )

#+end_src

**** Org pandoc import
#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp
(use-package! org-pandoc-import :after org)
#+end_src

**** org roam :org:roam:
#+begin_src emacs-lisp :tangle packages.el
(unpin! org-roam)
(package! websocket)
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")))
#+end_src

#+begin_src emacs-lisp
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src
**** org modern

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern)
#+end_src

#+begin_src emacs-lisp
(use-package! org-modern :defer t)
#+end_src
**** org-remark
#+begin_src emacs-lisp :tangle packages.el
(package! org-remark)
#+end_src

#+begin_src emacs-lisp
(use-package! org-remark
   :defer t
   :init
   (map! :g "C-c n m" #'org-remark-mark
         (:after org-remark
          (:map org-remap-mode-map
           (:prefix "C-c n"
            :g "o" #'org-remark-open
            :g "]" #'org-remark-view-next
            :g "[" #'org-remark-view-previous
            :g "r" #'org-remark-remove)))))
#+end_src
**** simple-comment-markup
#+begin_src emacs-lisp :tangle packages.el
(package! simple-comment-markup :recipe (:repo "https://git.tecosaur.net/tec/simple-comment-markup.git"))
#+end_src

#+begin_src emacs-lisp
(use-package simple-comment-markup
  :hook (org-mode . simple-comment-markup-mode))
#+end_src

*** emacs lisp :emacsLisp:
in the ever growing emacs ecosystem the amount of prefixes you can use are
shrinking and as microcosoms open up and connections need to be reenforced it
all leads us down the slippery slope of ever lengthening prefixes. this godly
package shortens them to make reading code a lot easier
#+begin_src emacs-lisp :tangle packages.el
(package! nameless)
#+end_src

#+begin_src emacs-lisp
(use-package! nameless
  :defer t
  :hook (emacs-lisp-mode-hook . nameless-mode)
  :config
  (setq nameless-global-aliases '(("d" . "doom"))
        nameless-private-prefix t)

  (map! :map emacs-lisp-mode-map
        :localleader
        "i" #'nameless-insert-name))
#+end_src
*** TODO SQL
#+begin_src emacs-lisp
(after! sql
  (add-to-list 'sql-connection-alist
               '(psql (sql-product 'postgres)
                      (sql-port 22)
                      (sql-server (read-from-minibuffer "server ip: ")))))
#+end_src

*** Caddy
Caddy is a webserver with its own file format
#+begin_src emacs-lisp :tangle packages.el
(package! caddyfile-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! caddyfile-mode
  :mode (("Caddyfile\\'" . caddyfile-mode)
         ("caddy\\.conf\\'" . caddyfile-mode)))
#+end_src
*** TODO vim
because sacrilege is fun
(this is mostly a mental exercise but it does work...) I can (alleged) also get lsp
support as well so this may be a fun project to take on
#+begin_src emacs-lisp :tangle packages.el
(package! vimrc-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! vimrc-mode
  :mode "\\.vim$\\'"
  :config)
;; (sp-local-pair 'vimrc-mode "\"" nil :actions :rem))
#+end_src
*** TODO unit tests
While I am in fact an incompetent programmer I do enjoy the sysiphisan task of
writing tests +thanks in no small part to the ease that cucumber makes it+
I was so ready to use it but it did not want too work with my ruby project :(

#+begin_src emacs-lisp :tangle packages.el
(package! feature-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! feature-mode
  :mode "\\.feature$\\'")
#+end_src
*** COMMENT Brainfuck
me get errors need fix
#+begin_src emacs-lisp :tangle packages.el
(package! brainfuck-mode)
#+end_src

#+begin_src emacs-lisp
(use-package! brainfuck-mode
  :mode "\\.bf$\\'")
#+end_src
*** janet
#+begin_src emacs-lisp :tangle packages.el
(package! janet-mode :recipe
  (:host github :repo "ALSchwalm/janet-mode"))
#+end_src

#+begin_src emacs-lisp
(use-package! janet-mode
  :mode "\\.janet$\\'")
#+end_src
*** shell
#+begin_src emacs-lisp :tangle packages.el
(package! flymake-shellcheck)
#+end_src

#+begin_src emacs-lisp
(use-package! flymake-shellcheck
  :commands flymake-shellcheck-load
  :init
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
#+end_src

** app
*** books :books:
I am starting to read more books and papers online so it makes sense to include
improve the experience somewhat
#+begin_src emacs-lisp :tangle packages.el
(package! nov)
(package! calibredb)
(package! olivetti)
(package! mixed-pitch)
#+end_src

Calibredb provides a nice interface for exploring adding and working with ebooks
I have stolen most of these keybinding from [[https://tecosaur.github.io/emacs-config/config.html#ebooks][@tecosaur]] (thanks for doing this
work so I don't have to) I have slightly modified them though to fit my needs.
#+begin_src emacs-lisp
(use-package! calibredb
  :defer t
  :config
  (setq calibredb-root-dir "~/Documents/reading/calibre"
        calibredb-db-dir   (expand-file-name "metadata.db" calibredb-root-dir))
  ;; the view for all books
  (map! :map calibredb-search-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "a" nil
        :ne "a" #'calibredb-add
        :ne "A" nil
        :ne "A" #'calibredb-add-dir
        :ne "." #'calibredb-open-dired
        :ne "e" #'calibredb-export-dispatch
        :ne "m" #'calibredb-mark-at-point
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "q" #'calibredb-search-quit
        :ne "s" nil
        :ne "s" #'calibredb-sort-dispatch
        :ne "S" #'calibredb-set-metadata-dispatch
        :ne "u" #'calibredb-unmark-at-point
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne [tab] #'calibredb-toggle-view-at-point)
  ;; the veiw for one book
  (map! :map calibredb-show-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-open-dired
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" nil
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))

(defun +book/quit ())

(defun =book ()
  (interactive)
  (if (modulep! :ui workspaces)
      (progn
        (+workspace-switch "*book*" t)
        (doom/switch-to-scratch-buffer)
        (calibredb)
        (+workspace/display))
    (calibredb)))

;; I read books more than I read files in my buffer
(map! :leader
      "ob" nil
      "ob" #'=book
      "oB" #'browse-url-of-file)
#+end_src

Nov is how we do the reading!
I don't configre it too much for the time being though I do plan on adding a
setup function that changes the theme and makes it pretty
#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (add-hook! 'nov-mode-hook #'olivetti-mode ;; Centers the text making it easier to read
    (mixed-pitch-mode +1)
    (defun yeet/nov-setup ()
      (setq-local olivetti-body-width 125))))

(after! olivetti)
#+end_src

#+RESULTS:
*** tldr integration
Ever wanted to.. not read a man page? me too. tldr is a good middle ground between
a lot of useless information and .. no information. Now in emacs!
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! tldr)
#+END_SRC

#+begin_src emacs-lisp
(use-package! tldr
  :config
  (setq tldr-directory-path (expand-file-name "tldr/" doom-etc-dir)) ;; don't be cluttering my work tree
  (setq tldr-enabled-categories '("common" "linux")))
#+end_src
*** rss
#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-tube :recipe (:host github :repo "karthink/elfeed-tube"))
#+end_src

#+begin_src emacs-lisp
(use-package elfeed-tube
  :after elfeed
  :config
  (setq elfeed-tube-auto-fetch-p t) ;;  t is auto-fetch (default)
  (elfeed-tube-setup)

  :bind (:map elfeed-show-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)
         :map elfeed-search-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)))
#+end_src
** other
*** tetris
who does not like a good game of tetris
#+begin_src emacs-lisp
;; center the board
(add-hook! 'tetris-mode-hook
           (defun yeet/center-tetris ()
             (setq-local olivetti-body-width 102)
             (olivetti-mode +1)))

(map! :after tetris
      :map tetris-mode-map
      :n "g" #'tetris-move-bottom
      :n "n" #'tetris-start-game
      :n "p" #'tetris-pause-game)
#+end_src

*** fixes
#+begin_src emacs-lisp :tangle packages.el
(package! xref :pin "a82f459b37b31546bf274388baf8aca79e9c30d9")
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! gitconfig-mode
  :recipe (:host github :repo "magit/git-modes"
           :files ("gitconfig-mode.el")))
(package! gitignore-mode
  :recipe (:host github :repo "magit/git-modes"
           :files ("gitignore-mode.el")))

;; This is temporarily necessary due to an unrelated bug.
(unpin! gitignore-mode gitconfig-mode)
#+end_src
*** discord rich presence
Why use emacs when you can't tell everyone your using emacs?
I am now using elcord because.. peer pressure? I don't know but the config is
nice
#+begin_src emacs-lisp :tangle packages.el
(package! elcord)
#+end_src
I use non daemon sessions for testing I would much rather it would not be used
(and block the closing of emacs)

#+begin_src emacs-lisp
(when (daemonp)
  (use-package! elcord ;; FIXME: flatpak discord can't pick up the calls :(
    :config
    (defun yeet/elcord-buffer-info ()
      "Get the buffer name or whether we are editing it or not and return a formatted string."
      (format "%s %s" (if buffer-read-only
                          "Reading"
                        "Editing")
              (buffer-name)))

    (setq elcord-quiet t
          elcord-use-major-mode-as-main-icon nil
          elcord-show-small-icon t
          elcord-buffer-details-format-function #'yeet/elcord-buffer-info)

    (elcord-mode +1)))
#+end_src
*** arrows
#+begin_src emacs-lisp :tangle packages.el
(package! arr :recipe (:local-repo "~/code/emacs/arrows"))
#+end_src

* Modules
These are the configurations for the doom specific modules. some are big like
mu4e, some are small like dired. some are well sized. They are all loved tho!
(except the deprecated ones.)
** completion :completion:
*** company :company:
Deals with completions something I like. I elect for manual completion but
defer the idle delay for those real brain fart seconds
#+BEGIN_SRC emacs-lisp
(after! company
  (setq company-idle-delay 6 ; I like my autocomplete like my tea. Mostly made by me but appreciated when someone else makes it for me
        ;; company-minimum-prefix-length 2
        company-show-numbers t))
#+END_SRC
*** DEPRECATED ivy :ivy:
Ivy is nice but +selectrum+ vertico is my friend
#+BEGIN_SRC emacs-lisp
(after! ivy
  (setq ivy-height 20
        ivy-wrap nil
        ivy-magic-slash-non-match-action t)
  (add-to-list 'ivy-re-builders-alist '(counsel-projectile-find-file . ivy--regex-plus)))
#+END_SRC

this is to make prescient a little more intelligent
#+BEGIN_SRC emacs-lisp
(setq-default history-length 10000)
(setq-default prescient-history-length 10000)
#+END_SRC
*** vertico :vertico:
#+begin_src emacs-lisp
(defvar-local consult-toggle-preview-orig nil)

(defun consult-toggle-preview ()
  "Command to enable/disable preview."
  (interactive)
  (if consult-toggle-preview-orig
      (setq consult--preview-function consult-toggle-preview-orig
            consult-toggle-preview-orig nil)
    (setq consult-toggle-preview-orig consult--preview-function
          consult--preview-function #'ignore)))

;; Bind to `vertico-map' or `selectrum-minibuffer-map'
(after! vertico
  (define-key vertico-map (kbd "M-o c") #'consult-toggle-preview))
#+end_src
**** marginalia
These are some small tweaks to marginalia I will probably add more as its kind
of fun!
#+begin_src emacs-lisp
(defun yeet/face-annotator (cand)
  "Annotate faces with dummy text and face documentation"
  (when-let (sym (intern-soft cand))
    (marginalia--fields
     ("The Quick Brown Fox Jumped Over The Lazy Dog" :face sym)
     ((documentation-property sym 'face-documentation)
      :truncate marginalia-truncate-width :face 'marginalia-documentation))))

(after! marginalia
  (add-to-list 'marginalia-annotator-registry
               '(face yeet/face-annotator marginalia-annotate-face builtin none)))
#+end_src
** editor :editor:
*** evil :evil:
Frankly I don't know why this is not default
(it automatically switches to a split)
#+BEGIN_SRC emacs-lisp
(after! evil
  (setq evil-split-window-below  t
        evil-vsplit-window-right t
        evil-disable-insert-state-bindings t
        evil-want-fine-undo t))
#+END_SRC
** ui :ui:
*** Doom :doom:
This is the main module to say what Doom looks like! I put all of my font
settings and all of that fun stuff here

+Inconsolata is the best font that *I* have used... but it does not italic well.+
+if you do know of a better way. do get in touch!+

Iosevka is my new best friend

#+BEGIN_SRC emacs-lisp
 ;; Change out fonts quickly
 (defvar yeet/font-name "Iosevka")

 (setq!
  doom-font (font-spec :family yeet/font-name :size 16)
  doom-big-font (font-spec :family yeet/font-name :size 25)
  ;; doom-font (font-spec :family yeet/font-name :size 16)
  ;; doom-big-font (font-spec :family yeet/font-name :size 25)
  doom-variable-pitch-font (font-spec :family "Merriweather" :size 17))

;; HACK to get rid of weird black circles in mu4e screen.
 (delete "Noto Emoji" doom-emoji-fallback-font-families)
 (delete "Noto Color Emoji" doom-emoji-fallback-font-families)
#+end_src

the comments for horizon are borderline unreadable so now we have brighter
comments
#+begin_src emacs-lisp
(setq! doom-themes-enable-bold t
        doom-themes-enable-italic t
        doom-horizon-brighter-comments t
        doom-flatwhite-brighter-modeline t)
#+end_src

I wanted my comments and keywords to be italics.
#+begin_src  emacs-lisp
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+END_SRC

My theme
this will load up 2 different themes one for the terminal and one for the gui.
turns out that the emacs client works differently so this is not something that
I can use... still works tho
#+begin_src emacs-lisp :tangle packages.el
(package! horizon-theme)
(unpin! doom-themes)
#+end_src

#+BEGIN_SRC emacs-lisp
(setq doom-theme (if (or (daemonp) (display-graphic-p))
                     'doom-horizon
                   'horizon))
#+end_src

*** Doom Dashboard :dashboard:

my splash image can be found [[https://github.com/jeetelongname/doom-banners ][here]]
#+BEGIN_SRC emacs-lisp
(setq fancy-splash-image "~/code/other/doom-banners/splashes/emacs/emacs-gnu-logo.png")
#+END_SRC

A futile reminder to get back to work
#+begin_src emacs-lisp
(add-hook! '+doom-dashboard-functions :append
  (insert "\n" (+doom-dashboard--center +doom-dashboard--width "Get back to work")))
#+end_src

This is again stolen from Tecosaur. All it does is insert a little message from
a couple of online apis.
#+begin_src emacs-lisp
(defvar phrase-api-url
  (nth (random 3)
       '(("https://corporatebs-generator.sameerkumar.website/" :phrase)
         ("https://useless-facts.sameerkumar.website/api" :data)
         ("https://dev-excuses-api.herokuapp.com/" :text))))

(defmacro phrase-generate-callback (token &optional format-fn ignore-read-only callback buffer-name)
  `(lambda (status)
     (unless (plist-get status :error)
       (goto-char url-http-end-of-headers)
       (let ((phrase (plist-get (json-parse-buffer :object-type 'plist) (cadr phrase-api-url)))
             (inhibit-read-only ,(when (eval ignore-read-only) t)))
         (setq phrase-last (cons phrase (float-time)))
         (with-current-buffer ,(or (eval buffer-name) (buffer-name (current-buffer)))
           (save-excursion
             (goto-char (point-min))
             (when (search-forward ,token nil t)
               (with-silent-modifications
                 (replace-match "")
                 (insert ,(if format-fn format-fn 'phrase)))))
           ,callback)))))

(defvar phrase-last nil)
(defvar phrase-timeout 5)

(defmacro phrase-insert-async (&optional format-fn token ignore-read-only callback buffer-name)
  `(let ((inhibit-message t))
     (if (and phrase-last
              (> phrase-timeout (- (float-time) (cdr phrase-last))))
         (let ((phrase (car phrase-last)))
           ,(if format-fn format-fn 'phrase))
       (url-retrieve (car phrase-api-url)
                     (phrase-generate-callback ,(or token "\ufeff") ,format-fn ,ignore-read-only ,callback ,buffer-name))
       ;; For reference, \ufeff = Zero-width no-break space / BOM
       ,(or token "\ufeff"))))

(defun doom-dashboard-phrase ()
  (phrase-insert-async
   (progn
     (setq-local phrase-position (point))
     (mapconcat
      (lambda (line)
        (+doom-dashboard--center
         +doom-dashboard--width
         (with-temp-buffer
           (insert-text-button
            line
            'action
            (lambda (_)
              (setq phrase-last nil)
              (+doom-dashboard-reload t))
            'face 'doom-dashboard-menu-title
            'mouse-face 'doom-dashboard-menu-title
            'help-echo "Random phrase"
            'follow-link t)
           (buffer-string))))
      (split-string
       (with-temp-buffer
         (insert phrase)
         (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
         (fill-region (point-min) (point-max))
         (buffer-string))
       "\n")
      "\n"))
   nil t
   (progn
     (goto-char phrase-position)
     (forward-whitespace 1))
   +doom-dashboard-name))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

I removed the helpful menu. I only use it for.. nothing. lets make it C L E A N
#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src
*** Hl TODO
I want a done face for TODO's that are now done ala org mode
#+begin_src emacs-lisp
(after! hl-todo
  (add-to-list 'hl-todo-keyword-faces `("DONE" org-done bold)))
#+end_src
*** Popup
#+begin_src emacs-lisp
;; (set-popup-rule! "\\*info*\\" :side 'right)
#+end_src
*** Modeline :modeline:
My modeline does a lot...
#+BEGIN_SRC emacs-lisp
(after! doom-modeline
  (setq doom-modeline-buffer-file-name-style 'auto
        doom-modeline-height 30
        doom-modeline-icon t
        doom-modeline-modal-icon nil
        doom-modeline-env-version t
        doom-modeline-buffer-modification-icon t
        doom-modeline-enable-word-count t
        doom-modeline-continuous-word-count-modes '(text-mode)
        doom-modeline-icon (display-graphic-p)
        doom-modeline-persp-name t
        doom-modeline-persp-icon t
        doom-modeline-github t
        doom-modeline-mu4e t))
#+END_SRC
This was all for a little padding. I could remove the stuff I don't need but
whats the fun in that?

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-modeline 'main
    '(bar workspace-name window-number modals matches buffer-info remote-host buffer-position word-count parrot selection-info)
    '(misc-info vcs persp-name grip irc mu4e github debug repl lsp minor-modes input-method indent-info buffer-encoding checker major-mode process " " bar " ")))
#+end_src

I stole this from @tecosaur Its frankly a great addition (this is a theme
throughout @tecosaurs config)
As we expect that the encoding is UTF-8 we remove it from the modeline untill we
get something that is not normal
#+BEGIN_SRC emacs-lisp

(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (or (eq buffer-file-coding-system 'utf-8-unix)
                          (eq buffer-file-coding-system 'utf-8)))))

(add-hook! 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+END_SRC

the persp name was too dark for my liking
#+begin_src emacs-lisp
(custom-set-faces! `(doom-modeline-persp-name :foreground ,(doom-color 'red) :weight bold )
  `(doom-modeline-buffer-modified   :foreground ,(doom-color 'orange))
  `(doom-modeline-buffer-major-mode :foreground ,(doom-color 'blue)))
#+end_src

*** Treemacs :treemacs:sidebars:
this provides a vscode like sidebar. I actually use dired a lot more but I guess
its still useful for presentation's (dired sidebar is actually all I need)
#+BEGIN_SRC emacs-lisp
(after! treemacs
  (setq +treemacs-git-mode 'extended
        treemacs-width 30))
#+END_SRC
*** Workspaces :workspaces:
This hot little number shows the workspaces whenever =SPC TAB= is hit. it makes
=SPC TAB TAB= redundant. I then remap it too something a little more useful

Thanks too @igorlamedia for it
#+begin_src emacs-lisp
(defadvice! rigor/which-key-show-workspace (orig-fun &rest pages-obj)
  "Show my workspaces in the echo thingy"
  :around #'which-key--process-page
  (let ((out (apply orig-fun pages-obj))
        (prefix-title (which-key--pages-prefix-title (car pages-obj))))
    (if (not (string-equal prefix-title "workspace"))
        out
      (cons (car out)
            (lambda ()
              (funcall (cdr out))
              (which-key--echo (concat (current-message) " " (+workspace--tabline))))))))

(map! :leader "TAB TAB" nil
      :leader "TAB TAB" #'+workspace/switch-to)
#+end_src
** tools :tools:
*** eval :eval:
I did not like the overlay as its greyed self so I picked something that would
stick out a little more
#+begin_src emacs-lisp
(custom-set-faces! `(eros-result-overlay-face
                     :foreground ,(doom-color 'violet)))
#+end_src

#+begin_src emacs-lisp
(after! eros
  (setq eros-eval-result-prefix "->  "))
#+end_src
*** magit
#+begin_src emacs-lisp
(map! :leader "gw" #'magit-worktree)
#+end_src
*** lsp :lsp:
file watchers crash emacs. I never know what they do anyway
#+begin_src emacs-lisp
(setq lsp-enable-file-watchers nil)

;; I also don't want suggested servers
(after! lsp-mode
  (setq lsp-enable-suggest-server-download nil))
#+end_src
*** pdf :pdf:
custom modeline for pdf files stolen from tecosaur and hopefully it will become
a default
#+begin_src emacs-lisp :tangle packages.el
(unpin! pdf-tools)
#+end_src

#+begin_src emacs-lisp
(after! (pdf-tools doom-modeline)
  (doom-modeline-def-segment pdf-icon
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (doom-modeline-def-segment buffer-name
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (concat " P"
                  (number-to-string (eval `(pdf-view-current-page)))
                  (propertize (concat "/" (number-to-string (pdf-cache-number-of-pages))) 'face 'doom-modeline-buffer-minor-mode))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number matches pdf-pages pdf-icon buffer-name)
    '(misc-info major-mode process vcs))

  (defun doom-set-pdf-modeline-h ()
    "sets the pdf modeline"
    (doom-modeline-set-modeline 'pdf))

  (add-hook! 'pdf-view-mode-hook 'doom-set-pdf-modeline-h))
#+end_src

*** tmux :tmux:
Sadly I can't live in emacs entirely. I have to use an outside terminal
this just makes it a little easier to orchestrate  my life in emacs
#+begin_src emacs-lisp
(after! evil
  (evil-ex-define-cmd "run" #'+tmux:run))
#+end_src
*** tree-sitter :treesitter:
current hack in testing
#+begin_src emacs-lisp
(after! tree-sitter
  (pushnew! tree-sitter-major-mode-language-alist
            '(scss-mode . css)))

(after! evil-textobj-tree-sitter
  (pushnew! evil-textobj-tree-sitter-major-mode-language-alist
            '(scss-mode . "css")))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! hideshow-tree-sitter
  :recipe
  (:local-repo "~/code/emacs/hideshow-tree-sitter"
   :files ( "*.el" "queries")))

(package! tree-sitter-playground :recipe (:local-repo "~/code/emacs/tree-sitter-playground"
                                          :build (:not compile)))
#+end_src

#+begin_src emacs-lisp
(use-package! hideshow-tree-sitter :after tree-sitter)
(use-package! tree-sitter-playground
  :after tree-sitter
  :config
  (setq tree-sitter-playground-jump-buttons t
        tree-sitter-playground-highlight-jump-region t))
#+end_src

The yellow used for function calls was the same colour used for strings (in
~doom-horizon~) so I changed it to blue for parity with function definition
#+begin_src emacs-lisp
(custom-set-faces!  `(tree-sitter-hl-face:function.call :foreground ,(doom-color 'blue)))

(after! evil-textobj-tree-sitter
  (map! (:map +tree-sitter-outer-text-objects-map
         "m" (+tree-sitter-get-textobj "import"
                                       '((python-mode . [(import_statement) @import])
                                         (rust-mode . [(use_declaration) @import]))))))
#+end_src
**** Tree edit
#+begin_src emacs-lisp :tangle packages.el
;; (package! tree-edit :recipe (:host github :repo "ethan-leba/tree-edit"))
(package! evil-tree-edit :recipe (:host github :repo "ethan-leba/tree-edit"))
#+end_src

#+begin_src emacs-lisp
(use-package! evil-tree-edit
  :hook (python-mode . evil-tree-edit-mode))
#+end_src

** emacs :emacs:
*** dired :dired:
If I open 2 instances of dired in two different locations then move/copy/symlink
a file. dired will point the move to the other location
#+begin_src emacs-lisp
(setq dired-dwim-target t)
#+end_src

I don't need all the file information all the time. thus I hide it by default
I may configure it too show some but not all (like the date)

#+begin_quote
Do note you can use =(= to toggle the information
#+end_quote

#+begin_src emacs-lisp
(add-hook! 'dired-mode-hook #'dired-hide-details-mode)
#+end_src

work on something to put in the dired header line
#+begin_src emacs-lisp
;; (setq-hook! 'dired-mode-hook
;;   header-line-format (concat (propertize )))
#+end_src
** term :term:
*** eshell :eshell:
eshell is a repl like shell. it works like a shell but you can use elisp in line
and it does not handle tui apps (like htop) usually defering to ~ansi-term~
#+begin_src emacs-lisp
(set-eshell-alias!
 "cls" "clear") ; this is what I use in my regular shell
#+end_src

**** TODO Shell prompt
Lets port my [[https://github.com/jeetelongname/yeet-theme][shell prompt]] for eshell
#+begin_src emacs-lisp
(defun yeet/current-git-branch ()
  "liteally just to change the format string"
  (let ((fstring " (%s)"))
    (cl-destructuring-bind (status . output)
        (doom-call-process "git" "symbolic-ref" "-q" "--short" "HEAD")
      (if (equal status 0)
          (format fstring output)
        (cl-destructuring-bind (status . output)
            (doom-call-process "git" "describe" "--all" "--always" "HEAD")
          (if (equal status 0)
              (format fstring output)
            ""))))))

(defun yeet/prompt-function ()
  (concat tramp-default-host ":"
          (format-time-string "(%a %d)")
          (yeet/current-git-branch)
          (propertize " ᐅ" 'face (if (zerop eshell-last-command-status) 'success 'error))
          " "))

;; (setq eshell-prompt-function #'yeet/prompt-function)
;; (setq eshell-prompt-regexp "\\.+:\\(\\.+\\)\\.+ᐅ ")
#+end_src
** checkers :checkers:
*** spell :spell:
This readds the functionality of spelling on =return=
#+begin_src emacs-lisp
(map! (:after spell-fu
       (:map override ;; HACK spell-fu does not define a modemap
        :n [return]
        (cmds! (memq 'flymake-error-face (face-at-point nil t))
               #'+spell/correct))))
#+end_src

** lang :lang:
*** emacs-lisp
#+begin_src emacs-lisp
;; (add-to-list '+emacs-lisp-disable-flycheck-in-dirs "~/code/emacs/tutorial")
#+end_src

*** org :org:
Org mode. our favorite plain text markup format! these are my configurations for
it

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org-notes/")
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "PROJ(p)" "LOOP(r)" "NEXT(n)" "WAIT(w)" "HOLD(h)" "IDEA(i)" "+DAY(+)" "TODAY(T)" "BLOG(B)" "|" "DONE(d)" "KILL(k)")
          (sequence "[ ](b)" "[-](S)" "[?](W)" "|" "[X](D)")
          (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

  (setq org-agenda-files (seq-map
                          (lambda (x)
                            (concat org-directory x))
                          '("tasks.org" "blog-ideas.org" "hitlist.org")) ;; FIXME make it more specific
        org-hide-emphasis-markers nil ;; this makes org feel more like a proper document and less like a mark up format
        org-startup-with-latex-preview t)

  (when (modulep! :lang org +pretty) ;; I used to use the +pretty flag but I now don't thus the `when'
    (setq org-fancy-priorities-list '("⚡" "⬆" "⬇" "☕")
          org-superstar-headline-bullets-list '("⁕" "܅" "⁖" "⁘" "⁙" "⁜"))))
#+end_src

As org has a lot of subheading's I wanted to tweak stuff ever so slightly thus
here we are. do note that I have copied all of the foreground info over that
because the ~inherit~ value (setter?, key? idk) did not exist until I looked it
up it would have looked like ~..:inherit outline-x~ where x is the level of the
heading you want to change. This just locks me into the horizon colour scheme
but there are worst things. The better way would be to change ~outline-x~
directly
#+begin_src emacs-lisp
(custom-set-faces!
  `(org-date :foreground ,(doom-color 'violet))
  '(org-document-title :height 1.75 :weight bold)
  `(org-level-1 :foreground ,(doom-color 'blue) :height 1.3 :weight normal)
  `(org-level-2 :foreground ,(doom-color 'grey) :height 1.1 :weight normal)
  `(org-level-3 :foreground ,(doom-color 'violet) :height 1.0 :weight normal)
  `(org-level-4 :foreground ,(doom-color 'cyan)   :height 1.0 :weight normal)
  `(org-level-5 :foreground ,(doom-color 'grey) :weight normal)
  `(org-level-6 :foreground ,(doom-color 'blue) :weight normal))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! org-capture
  (setq org-capture-templates
        '(("n" "Note" entry (file+olp+datetree "slipbox.org") "**** %T %?" :prepend t :kill-buffer t)
          ("t" "Task" entry (file+headline "tasks.org" "Inbox") "**** TODO %U %?\n%i" :prepend t :kill-buffer t)
          ("b" "Blog" entry (file+headline "blog-ideas.org" "Ideas") "**** +DAY  %?\n%i" :prepend t :kill-buffer t)
          ("U" "UTCR" entry (file+headline "UTCR-TODO.org" "Tasks") "**** TODO %?\n%i" :prepend t :kill-buffer t))))
#+END_SRC

Cooking in org has never been this easy!
FIXME
#+begin_src emacs-lisp
;; (use-package! org-cook
;;   :after org)
#+end_src
Below you will see a configuration for roam and journal. The reason I have both
is because I make 2 kinds of notes. one is for my head (which are linear) and
the other is for my school (which are non linear) roam has been a god sent for
note taking while journal has been a god sent for just getting my thoughts out
on paper I recommend both
**** Roam
#+begin_src emacs-lisp
(setq org-roam-directory (concat org-directory "roam/")
      org-roam-db-location (concat org-roam-directory ".org-roam.db"))
#+end_src

I dislike having org roam buffers litter my workspaces so I just force them into
there own workspace for ease and peace of mind
#+begin_src emacs-lisp
(defadvice! yeet/org-roam-in-own-workspace-a (&rest _)
  "Open all roam buffers in there own workspace."
  :before #'org-roam-node-find
  :before #'org-roam-node-random
  :before #'org-roam-buffer-display-dedicated
  :before #'org-roam-buffer-toggle
  (when (modulep! :ui workspaces)
    (+workspace-switch "*roam*" t)))
#+end_src
**** Journal
I don't need people snooping into my thoughts
#+begin_src emacs-lisp
(after! org-journal
  (setq org-journal-enable-encryption t
        org-journal-encrypt-journal t))
#+end_src

**** org agenda
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! origami)
(package! org-super-agenda)
#+END_SRC

#+begin_src emacs-lisp
(use-package! org-super-agenda
  :commands org-super-agenda-mode)

(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(after! org-agenda
  (setq org-agenda-custom-commands
        '(("o" "Overview"
           ((agenda "" ((org-agenda-span 'day)
                        (org-super-agenda-groups
                         '((:name "Today"
                            :time-grid t
                            :date today
                            :todo "TODAY"
                            :scheduled today
                            :order 1)))))
            (alltodo "" ((org-agenda-overriding-header "")
                         (org-super-agenda-groups
                          '((:name "Next to do"
                             :todo "NEXT"
                             :order 1)
                            (:name "Due Today"
                             :deadline today
                             :order 2)
                            (:name "Important"
                             :tag "Important"
                             :priority "A"
                             :order 6)
                            (:name "Overdue"
                             :deadline past
                             :scheduled past
                             :face error
                             :order 7)
                            (:name "Due Soon"
                             :deadline future
                             :order 8)
                            (:name "University"
                             :tag "uni"
                             :order 10)
                            (:name "Issues"
                             :tag "issue"
                             :order 12)
                            (:name "Projects"
                             :todo "PROJ"
                             :tag "project"
                             :order 14)
                            (:name "Back Burner"
                             :order 40
                             :todo "+DAY"
                             :todo "BLOG")
                            (:name "Trivial"
                             :priority<= "E"
                             :tag ("Trivial" "Unimportant")
                             :order 90)
                            (:discard (:tag ("chore" "routine" "Daily"))))))))))))
#+end_src

*** haskell
I have been pretty lazy when it comes to learning haskell
#+begin_src emacs-lisp
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "ormolu"))
#+end_src
*** python :python:
Python is great is it not 🐍
#+BEGIN_SRC emacs-lisp
(setq! +python-ipython-command '("ipython3" "-i" "--simple-prompt" "--no-color-info"))
(set-repl-handler! 'python-mode #'+python/open-ipython-repl)
#+END_SRC
*** racket
racket is slowly becoming my favorite language

adding unicode input
#+begin_src emacs-lisp
(add-hook 'racket-mode-hook      #'racket-unicode-input-method-enable)
(add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)
#+end_src

*** LaTeX :LaTeX:
#+BEGIN_SRC emacs-lisp
(setq +latex-viewers '(pdf-tools zathura)) ;; don't be going to those filthy third party apps
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :map cdlatex-mode-map
      :i "TAB" #'cdlatex-tab)
#+END_SRC

*** Web :web:
I just find the tidy formatter indent functionality annoying and redundant. so
I changed it
#+begin_src emacs-lisp
(setenv "HTML_TIDY" (expand-file-name "tidy.conf" doom-private-dir))
(setq +format-on-save-enabled-modes
      '(not web-mode))
#+end_src

Why leave emacs too compile sass?  TODO take an input and output dir
#+begin_src emacs-lisp :tangle autoload.el
(defun yeet/scss-compile (watch)
  "Get sass compiling my scss files."
  (start-process-shell-command
   "sass-compile" "*sass-compile-log*"
   (concat "sass "
           (if watch "--watch " " ")
           (concat (projectile-acquire-root) "css/scss") ":"
           (concat (projectile-acquire-root) "css" )
           " --no-color")))

;;;###autoload
(defun yeet/scss-build ()
  "Build Scss files in directory."
  (interactive)
  (yeet/scss-compile nil)
  (message "SCSS Compiled!"))

;;;###autoload
(defun yeet/scss-start ()
  "Watch Scss file in directory."
  (interactive)
  (yeet/scss-compile t))

;;;###autoload
(defun yeet/scss-stop ()
  "Kill any current scss processes"
  (interactive)
  (delete-process "sass-compile")
  (message "Sass process killed"))

#+end_src

#+begin_src emacs-lisp
(map! (:map 'scss-mode-map
       :localleader
       "b" nil
       (:prefix ("s" . "sass")
        "b" #'yeet/scss-build
        "c" #'yeet/scss-start
        "C" #'yeet/scss-stop)))
#+end_src
TODO caddy integration
**** css
I use sass and sadly the css-ls does not really work that well. I am going to
stick with the lsp less life for css
#+begin_src emacs-lisp
(remove-hook! '(scss-mode-local-vars-hook
                sass-mode-local-vars-hook)
  #'lsp!)
#+end_src
** app :app:
*** irc :irc:
I have a beard and I do like wasting time...
#+begin_src emacs-lisp
(after! circe
  (set-irc-server! "irc.eu.libera.chat"
    `(:tls t
      :port 6697
      :nick "jeetelongname"
      :sasl-username "jeetelongname"
      :sasl-password ,(+pass-get-secret "social/freenode")
      :channels ("#emacs" "#haskell" "#doomemacs"))))
#+end_src

I don't really need the notifications
#+begin_src emacs-lisp :tangle packages.el
(package! circe-notifications :disable t)
#+end_src
*** rss :rss:
Elfeed is great. I just need more blogs

I am now kinda the maintainer of elfeed-goodies...
#+begin_src emacs-lisp :tangle packages.el
(package! elfeed-goodies
  :recipe (:local-repo "~/code/emacs/elfeed-goodies"
           :build (:not compile))
  :disable nil)
#+end_src

#+BEGIN_SRC emacs-lisp
(after! elfeed
  (setq elfeed-search-filter "@4-week-ago -fun") ;; /they post so much/

  (setq rmh-elfeed-org-files (list (concat org-directory "elfeed.org"))) ;; +org
  (add-hook! 'elfeed-search-mode-hook 'elfeed-update)) ; update on entry

(after! elfeed-goodies
  (setq elfeed-goodies/powerline-default-separator 'bar))

(defadvice! yeet/open-content-in-eww-a (orig-fun &rest args)
  :around #'elfeed-search-browse-url
  (let ((browse-url-browser-function #'eww-browse-url))
    (funcall orig-fun args)))
#+END_SRC

There have been times where I wanted to share a link to an interesting blog or a
comic that made me laugh. this just automated that process
#+begin_src emacs-lisp :tangle autoload.el
;; not actually useful as you can just use =title to filter by title
;;;###autoload
(defun yeet/search-feeds-by-title (feed-title)
  (interactive
   (list (completing-read
          "Select Feed"
          (let (feed-titles)
            (dolist (feed elfeed-feeds feed-titles)
              (push (cons (elfeed-feed-title (elfeed-entry-feed (car (elfeed-feed-entries (car feed)))))
                          (car feed))
                    feed-titles))))))
  (message "%s"  feed-title))
#+end_src

#+begin_src emacs-lisp
;; (map! (:map elfeed-show-mode-map
;;        :n "gc" nil
;;        :n "gc" #'yeet/elfeed-copy-link))
#+end_src

*** mu4e :mu4e:
Whats better than email? email in emacs! mu4e has been fine for me so I dont
think I will be switching to notmuch or what notj

Setting my email using ~set-email-acount~. its a simple affair If you are stuck
on the folders remember that they come from what you set in your [[https://github.com/jeetelongname/dotfiles/blob/master/mail/.mbsyncrc#L31][mail fetcher config]]
#+BEGIN_SRC emacs-lisp
(set-email-account! "gmail"
                    '((mu4e-sent-folder       . "/gmail/\[Gmail\]/Sent Mail")
                      (mu4e-drafts-folder     . "/gmail/\[Gmail\]/Drafts")
                      (mu4e-trash-folder      . "/gmail/\[Gmail\]/Trash")
                      (mu4e-refile-folder     . "/gmail/\[Gmail\]/All Mail")
                      (smtpmail-smtp-user     . "jeetelongname@gmail.com")
                      (org-msg-greeting-fmt   . "\nHi %s,\n\n")
                      (org-msg-signature      . "\nRegards,
 ,,#+begin_signature
 -- *Jeetaditya Chatterjee* \\\\
 /Sent using my text editor/
 ,,#+end_signature"))
                    t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq mu4e-mu-version "1.8.10")
  (setq smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 25))
#+END_SRC

I use msmtp to send my mail as its a little faster and has room for expansion
#+begin_src emacs-lisp
(setq sendmail-program (executable-find "msmtp")
      send-mail-function #'smtpmail-send-it
      message-sendmail-f-is-evil t
      message-sendmail-extra-arguments '("--read-envelope-from")
      message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

Adding some keybinding under local-leader. this should make it a little easier to
do mail stuff. I do like =C-c C-c= to send tho
#+begin_src emacs-lisp
(map! (:map org-msg-edit-mode-map
       :n "<tab>" #'org-msg-tab
       :localleader
       (:prefix "m"
        "k" #'org-msg-edit-kill-buffer
        "s" #'message-goto-subject
        "b" #'org-msg-goto-body
        "a" #'org-msg-attach)))
#+end_src

These are the settings for org-msg I may switch them to a snippet tho as I can
toggle the kind of signature I want to use then
#+BEGIN_SRC emacs-lisp
#+END_SRC

I don't like the default replied face
#+begin_src emacs-lisp
(custom-set-faces! `(mu4e-replied-face :foreground ,(doom-color 'red) :inherit font-lock-builtin-face))
#+end_src

I update my mail when I feel like it so this is a little redundant for me
#+begin_src emacs-lisp :tangle packages.el
(package! mu4e-alert :disable t)
#+end_src

*** everywhere :everywhere:
I prefer to write in the language that is going to be posted so markdown mode
makes more sense to be the default (which is org)
#+begin_src emacs-lisp
;; (after! emacs-everywhere
;;   (add-hook! 'emacs-everywhere-init-hooks 'markdown-mode)
;;   (remove-hook! 'emacs-everywhere-init-hooks 'org-mode))
#+end_src
* Epilogue
And that was my config! I hope you liked it! If you did not then you can make an
[[https://github.com/jeetelongname/.doom/issues][issue]] and if you just want to say I suck then i guess you can use that for that
too. I guess this is it for me... I am going back to bed
